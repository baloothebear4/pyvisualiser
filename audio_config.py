#!/usr/bin/env python
"""
 
 Creates the asound.config file for audio output configuration.  This changes dynamically according to which cards are available.
 The configuration is created for use with preDAC hardware, but can be adapted for other hardware by changing the card names.


 v1.0 Baloothebear4 Oct 25 2025 - Original version (aided by Gemini v2.5)

"""

import subprocess
import os
import re
from typing import Optional, Dict

# --- Configuration ---
# File path for the ALSA configuration file
ASOUND_CONF_PATH = '/etc/asound.conf'
# Card identification names to search for a USB DAC (case-insensitive)


# Sets asound.conf with routes and slaves to ensure that the ouput from streameed devices all go to:
# 1. Permanent internal devices (HAT DAC/ADC, Loopback)
# 2. Conditional external device (USB DAC) if/when plugged in on startup
#
LOOPBACK_KEYWORDS   = ['loopback', 'snd_aloop']
HAT_DAC_KEYWORDS    = ['HiFiBerry DAC+ADC HiFi', 'snd_rpi_hifiberry_dacplusadc']
USB_DAC_KEYWORDS    = ['usb audio', 'ARCAM USB Audio 2.0']


def get_sound_card_info() -> Dict[int, str]:
    """
    Executes 'aplay -l' and parses the output to get card index and name.
    
    Returns:
        A dictionary mapping card index (int) to card name (str).
    """
    print("--- Checking for available sound cards (via 'aplay -l') ---")
    try:
        # Run aplay -l to list sound cards
        result = subprocess.run(
            ['aplay', '-l'], 
            capture_output=True, 
            text=True, 
            check=True
        )
        output = result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error running aplay -l: {e}")
        return {}
    except FileNotFoundError:
        print("Error: 'aplay' command not found. Is ALSA installed?")
        return {}

    card_info = {}
    # Regex to capture the card index and the name in the first line of each block
    # Example line: "card 0: b1 [bcm2835 HDMI 1], device 0: bcm2835 HDMI 1 [bcm2835 HDMI 1]"
    card_pattern = re.compile(r'^card (\d+): [^[]+ \[(.+?)\],', re.MULTILINE)
    
    matches = card_pattern.findall(output)
    
    for index_str, name in matches:
        card_index = int(index_str)
        # Clean up the name (remove extra spaces/tabs)
        card_name = name.strip()
        card_info[card_index] = card_name
        print(f"Detected Card {card_index}: {card_name}")
        
    return card_info


def detect_cards(card_info: Dict[int, str]) -> Dict['str','str']:
    """
    Checks the detected cards for names matching USB DAC keywords.
    
    Args:
        card_info: Dictionary of detected card indices and names.
        
    Returns:
        The index (int) of the first matching USB DAC card, or None if not found.
    """

    cards_found = {'loopback': None, 'adc_dac': None, 'usb_dac': None}

    for index, name in card_info.items():

        for keyword in LOOPBACK_KEYWORDS:
            if keyword in name.lower():
                print(f"Loopback detected on Card {index}: {name}")
                cards_found['loopback'] = index
                continue

        for keyword in USB_DAC_KEYWORDS:
            if keyword in name.lower():
                print(f"USB DAC detected on Card {index}: {name}")
                cards_found['usb_dac'] = index
                continue

        for keyword in HAT_DAC_KEYWORDS:
            if keyword in name.lower():
                print(f"HAT ADC/DAC detected on Card {index}: {name}")
                cards_found['adc_dac'] = index
                continue
                
    return cards_found


def generate_asound_conf(dac_index: Optional[int]) -> str:
    """
    Generates the content for /etc/asound.conf.
    """
    
    # Standard definitions for permanent devices (HAT and Loopback)
    config_lines = [
        "# --- Dynamic ALSA Configuration generated by audio_configurator.py ---",
        "",
        "# Loopback (for internal routing)",
        "pcm.loopin {",
        "    type plug  # plug handles rate conversion",
        "    slave {",
        "        pcm {",
        f"            type hw",
        f"            card {dac_index['loopback']}",
        f"            device 1",
        "        }",
        "    }",
        "}",
        "",
        "pcm.loopout {",
        "    type hw",
        f"    card {dac_index['loopback']}",
        "    device 0",
        "}",
        "",
    ]
    
    # Conditional definition for HAT ADC/DACs
    if dac_index['adc_dac'] is not None:
        config_lines.extend([
            "#HiFi Berry DAC ADC device",
            "pcm.dac {",
            "    type hw",
            f"    card {dac_index['adc_dac']}",
            "    device 0",
            "}",
            "",
            "# ADC (for internal routing)",
            "pcm.adc {",
            "    type plug  # plug handles rate conversion",
            "    slave {",
            "        pcm {",
            f"            type hw",
            f"            card {dac_index['adc_dac']}",
            f"            device 0",
            "        }",
            "    }",
            "}",
            "",
        ])

    # Conditional definition for USB DACs
    if dac_index['usb_dac'] is not None:
        config_lines.extend([
            "#USB attached DAC device",
            "pcm.usb {",
            "    type hw",
            f"    card {dac_index['usb_dac']}",
            "    device 0",
            "}",
            "",
        ])

# Create a multi-device that sends to both DAC and loopback
    config_lines.extend([
        "pcm.multi_out {",
        "    type plug",
        "    slave.pcm {",
        "        type multi",
        "        slaves {",
        "            a { channels 2 pcm \"dac\" }",
        "            b { channels 2 pcm \"loopout\" }",])
    if dac_index['usb_dac'] is not None:
        config_lines.extend([
        "            c { channels 2 pcm \"usb\" }",])
    config_lines.extend([
        "        }",
        "        bindings {",
        "            0 { slave a channel 0 }",
        "            1 { slave a channel 1 }",
        "            2 { slave b channel 0 }",
        "            3 { slave b channel 1 }", ])
    if dac_index['usb_dac'] is not None:
        config_lines.extend([
        "            4 { slave c channel 0 }",
        "            5 { slave c channel 1 }",])
    config_lines.extend([
        "        }",
        "    }",
        "    ttable [",])
    if dac_index['usb_dac'] is not None:
        config_lines.extend([
        "        [ 1 0 1 0 1 0 ]  # Left channel to both outputs",
        "        [ 0 1 0 1 0 1 ]  # Right channel to both outputs",])
    else:
        config_lines.extend([
        "        [ 1 0 1 0 ]  # Left channel to both outputs",
        "        [ 0 1 0 1 ]  # Right channel to both outputs",])

    config_lines.extend([
        "    ]",
        "}", 
        "",
        "# Make this the default",
        "pcm.!default {",
        "    type plug",
        "    slave.pcm \"multi_out\"",
        "}",
    ])

    return '\n'.join(config_lines)


def write_asound_conf(content: str):
    """
    Writes the generated content to the /etc/asound.conf file.
    """
    try:
        with open(ASOUND_CONF_PATH, 'w') as f:
            f.write(content)
        print(f"\nSuccessfully wrote updated configuration to {ASOUND_CONF_PATH}.")
        print(f"Default PCM is now multi_out")
    except PermissionError:
        print(f"\nERROR: Permission denied. Must run as root (or via sudo/systemd) to write to {ASOUND_CONF_PATH}.")
    except Exception as e:
        print(f"\nAn unexpected error occurred while writing the file: {e}")


if __name__ == "__main__":
    # 1. Detect all cards
    all_cards = get_sound_card_info()
    
    # 2. Check for USB DAC
    usb_dac_index = detect_cards(all_cards)
    
    # 3. Generate the configuration
    conf_content = generate_asound_conf(usb_dac_index)
    print("\nGenerated /etc/asound.conf content:\n")
    print(conf_content) 

    # 4. Write the file
    write_asound_conf(conf_content)
    
    print("\nConfiguration complete. Proceeding to startup services...")

